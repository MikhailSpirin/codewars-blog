<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>development on CodeWars Dao</title>
    <link>https://mikhailspirin.github.io/codewars-blog/tags/development/</link>
    <description>Recent content in development on CodeWars Dao</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 25 May 2021 00:00:00 +0300</lastBuildDate><atom:link href="https://mikhailspirin.github.io/codewars-blog/tags/development/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kata 40 Last Survivor 2</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/40-last-survivor-2/</link>
      <pubDate>Tue, 25 May 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/40-last-survivor-2/</guid>
      <description>My solution function lastSurvivors(str) { const hasDuplicates = (arr) =&amp;gt; new Set(arr).size !== arr.length; let str_arr = str.split(&amp;#34;&amp;#34;).map(x=&amp;gt;x.charCodeAt(0)); while (hasDuplicates(str_arr)) { for (const c of str_arr) { [first,last] = [str_arr.indexOf(c), str_arr.lastIndexOf(c)] if (first !== last) { str_arr[first] = (c == 122) ? 97 : str_arr[first] + 1; str_arr.splice(last, 1); break; } } } return str_arr.map(x=&amp;gt;String.fromCharCode(x)).join(&amp;#34;&amp;#34;); }  Ok so i spent some time on this. Main problem is that i tried to solve this kata with ES6 abilities - but i failed.</description>
    </item>
    
    <item>
      <title>Kata 39 Chess Fun Cell Color</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/39-chess-fun-cell-color/</link>
      <pubDate>Mon, 24 May 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/39-chess-fun-cell-color/</guid>
      <description>https://www.codewars.com/kata/5894134c8afa3618c9000146
My solution function chessBoardCellColor(cell1, cell2) { const parity = (cell) =&amp;gt; (&amp;#34;_ABCDEFGH&amp;#34;.indexOf(cell.split(&amp;#34;&amp;#34;)[0]) + Number(cell.split(&amp;#34;&amp;#34;)[1])) % 2 == 0; return parity(cell1) === parity(cell2) }  Ok, that was simple. Can&amp;rsquo;t find better solution in solutions.</description>
    </item>
    
    <item>
      <title>Kata 38 Which Are In</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/38-which-are-in/</link>
      <pubDate>Fri, 21 May 2021 12:25:49 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/38-which-are-in/</guid>
      <description>https://www.codewars.com/kata/550554fd08b86f84fe000a58/
My solution function inArray(array1,array2){ return array1.filter(e =&amp;gt; array2.some(str=&amp;gt;str.indexOf(e) != -1)).sort((a,b)=&amp;gt;a.localeCompare(b)) }  Cool, that was really simple)</description>
    </item>
    
    <item>
      <title>Kata 37 Traffic Jam</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/37-traffic-jam/</link>
      <pubDate>Thu, 20 May 2021 14:15:32 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/37-traffic-jam/</guid>
      <description>https://www.codewars.com/kata/5a26073ce1ce0e3c01000023
My solution var trafficJam = function(mainRoad, sideStreets) { let mr = mainRoad.split(&amp;#34;&amp;#34;); let out = sideStreets.reduceRight((acc,curr,i)=&amp;gt;{ if (curr!=&amp;#34;&amp;#34;) { curr.split(&amp;#34;&amp;#34;).reverse().forEach((e,ei)=&amp;gt;mr.splice(i+ei*2+1, 0, e)); return mr; } else return mr; }, mr); return out.slice(0,mr.indexOf(&amp;#34;X&amp;#34;)+1).join(&amp;#34;&amp;#34;); }  That was the most amazing moment in my (not-yet-started) dev career. Really. I spent almost whole day on this kata. Couldn&amp;rsquo;t understand the approach. Tried different ones.
Main moment here is when i started to investigate, if all separate side roads addding can be somehow atomic - not like 1 car by 1 car, but whole line of cars.</description>
    </item>
    
    <item>
      <title>Kata 35 Snake Collision</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/35-snake-collision/</link>
      <pubDate>Tue, 18 May 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/35-snake-collision/</guid>
      <description>My solution function snakeCollision(g, m){ let snake = [[0, 0],[0, 1],[0, 2]]; let d = &amp;#34;R&amp;#34;; let steps = 0; const isFood = (cords) =&amp;gt; g[cords[0]][cords[1]]==&amp;#39;$&amp;#39;; const isSnake = (cords) =&amp;gt; snake.some((e)=&amp;gt;(e[0]==cords[0] &amp;amp;&amp;amp; e[1]==cords[1])); const isBorder = (cords) =&amp;gt; (cords[0] &amp;lt; 0 || cords[0] &amp;gt;= 13 || cords[1] &amp;lt; 0 || cords[1] &amp;gt;= 21); const head = () =&amp;gt; snake[snake.length-1]; const move = (d) =&amp;gt; { let dest; switch (d) { case &amp;#34;D&amp;#34;: dest = [head()[0]+1, head()[1]]; break; case &amp;#34;R&amp;#34;: dest = [head()[0], head()[1]+1]; break; case &amp;#34;U&amp;#34;: dest = [head()[0]-1, head()[1]]; break; case &amp;#34;L&amp;#34;: dest = [head()[0], head()[1]-1]; break; } if (isBorder(dest)) return false; if (isSnake(dest)) return false; snake.</description>
    </item>
    
    <item>
      <title>Kata 36 Merge Strings Checker</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/36-merge-strings-checker/</link>
      <pubDate>Mon, 17 May 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/36-merge-strings-checker/</guid>
      <description>https://www.codewars.com/kata/54c9fcad28ec4c6e680011aa
My solution function isMerge(s, part1, part2) { const takeFromFirst = (s,arr1,arr2) =&amp;gt; { for (let i in s) { if (s[i]==arr1[i] &amp;amp;&amp;amp; s[i]==arr2[i] ) continue; if (s[i]==arr1[i] &amp;amp;&amp;amp; s[i]!==arr2[i]) return true; if (s[i]!==arr1[i] &amp;amp;&amp;amp; s[i]==arr2[i]) return false; } } let [part1arr, part2arr] = [part1.split(&amp;#34;&amp;#34;), part2.split(&amp;#34;&amp;#34;)]; for (let i in s) { if (s[i] == part1arr[0] &amp;amp;&amp;amp; s[i] == part2arr[0]) { console.log(&amp;#34;we have very complicated situation here&amp;#34;); if (takeFromFirst(s.slice(i), part1arr, part2arr)) part1arr.</description>
    </item>
    
    <item>
      <title>Kata 34 Sort Strings Vowels</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/34-sort-strings-vowels/</link>
      <pubDate>Sun, 16 May 2021 22:44:54 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/34-sort-strings-vowels/</guid>
      <description>https://www.codewars.com/kata/5d2d0d34bceae80027bffddb
My solution const srt = (a,b) =&amp;gt; { if (a.length == b.length) return 0; return a.length &amp;gt; b.length ? -1 : 1 } const longestsubstr = (e) =&amp;gt; (e.match(/[aeiouAEIOU]+/gm) || []).sort(srt)[0]; function sortStringsByVowels(strings){ return strings.sort((a,b) =&amp;gt; srt((longestsubstr(a) || []),(longestsubstr(b) || []))); }  Well i think my solution is clearer) definitely i must have refactored my sorting function. But im really happy i managed to get the general approach. Also i think it&amp;rsquo;s not 6, its definitely 5 kyu&amp;hellip;</description>
    </item>
    
    <item>
      <title>Kata 33 Simple Fun Best Match</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/33-simple-fun-best-match/</link>
      <pubDate>Sat, 15 May 2021 15:03:14 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/33-simple-fun-best-match/</guid>
      <description>My solution function bestMatch(ALAHLYGoals, zamalekGoals) { const srt = (a,b)=&amp;gt;{ if (a[0]==b[0] &amp;amp;&amp;amp; a[1]&amp;gt;b[1]) return -1; if (a[0]==b[0] &amp;amp;&amp;amp; a[1]&amp;lt;b[1]) return 1; if (a[0]==b[0] &amp;amp;&amp;amp; a[1]==b[1] &amp;amp;&amp;amp; a[2]&amp;gt;b[2]) return 1; if (a[0]==b[0] &amp;amp;&amp;amp; a[1]==b[1] &amp;amp;&amp;amp; a[2]&amp;lt;b[2]) return -1; return a[0]&amp;gt;b[0] ? 1 : -1; } return zamalekGoals.map((e,i)=&amp;gt;[ALAHLYGoals[i]-e, e, i]).sort(srt)[0][2]; }  Best another solution function bestMatch(aGoals, bGoals) { return bGoals .reduce((best, goals, i) =&amp;gt; { const diff = aGoals[i] - goals; return !</description>
    </item>
    
    <item>
      <title>Kata 32 String Incrementer</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/32-string-incrementer/</link>
      <pubDate>Fri, 14 May 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/32-string-incrementer/</guid>
      <description>https://www.codewars.com/kata/54a91a4883a7de5d7800009c/
My solution const inc_zeros = (n) =&amp;gt; { let r = `${+n+1}`; while (r.length&amp;lt;n.length) r = `0${r}`; return r } function incrementString (strng) { return strng.replace(/(\D*)(\d*$)/, (_,p1,p2,offset,s) =&amp;gt; { console.log(p1,p2); if (p2.length == 0) return `${p1}1`; if (p2.length == p2.replace(/^0+/, &amp;#39;&amp;#39;).length) return `${p1}${+p2+1}` else return `${p1}${inc_zeros(p2)}`; } ); }  It was hard kata for me, becasue i didn&amp;rsquo;t manage to find beautiful solution. I feel like mine is bad, but i cant figure out what to refactor.</description>
    </item>
    
    <item>
      <title>Kata 31: New Holiday</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/31-new-holiday/</link>
      <pubDate>Thu, 06 May 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/31-new-holiday/</guid>
      <description>https://www.codewars.com/kata/58982a388927f70d8b000111/
My solution function holiday(x, weekDay, month, yearNumber) { const months = [&amp;#34;January&amp;#34;, &amp;#34;February&amp;#34;, &amp;#34;March&amp;#34;, &amp;#34;April&amp;#34;, &amp;#34;May&amp;#34;, &amp;#34;June&amp;#34;, &amp;#34;July&amp;#34;, &amp;#34;August&amp;#34;, &amp;#34;September&amp;#34;, &amp;#34;October&amp;#34;, &amp;#34;November&amp;#34;, &amp;#34;December&amp;#34;]; const leapyear = ((yearNumber % 100 === 0) ? ( yearNumber % 400 === 0) : (yearNumber % 4 === 0)); const daysinmonths = [31, leapyear ? 29 : 28 , 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; let days = [&amp;#34;Sunday&amp;#34;, &amp;#34;Monday&amp;#34;, &amp;#34;Tuesday&amp;#34;, &amp;#34;Wednesday&amp;#34;, &amp;#34;Thursday&amp;#34;, &amp;#34;Friday&amp;#34;, &amp;#34;Saturday&amp;#34;]; let firstday = (new Date(`${month}1, ${yearNumber}`)).</description>
    </item>
    
    <item>
      <title>Kata 30: Advanced Pig Latin</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/30-advanced-pig-latin/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/30-advanced-pig-latin/</guid>
      <description>My solution function piggify(w) { let isCapital = w[0] === w[0].toUpperCase(); let regex = /(^[b-df-hj-np-tv-z]*)([aeoui]\w*)(\W*)/; let piggified = w.toLowerCase().replace(regex, (_,p1,p2,p3)=&amp;gt;{ return (p1.length==0) ? `${p2}way${p3}` : `${p2}${p1}ay${p3}` }) return isCapital ? `${piggified[0].toUpperCase()}${piggified.slice(1)}` : piggified } function translate(sentence) { return sentence.split(&amp;#34; &amp;#34;).map(piggify).join(&amp;#34; &amp;#34;); };  Look i spent some time trying to avoid regexp here) But soon understood that this adds ineviteable complexity. Thing is its manipulating chunks of string - exactly regexp is probably the best fit.</description>
    </item>
    
    <item>
      <title>Kata 29 Lazy Evaluation</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/29-lazy-eval/</link>
      <pubDate>Wed, 28 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/29-lazy-eval/</guid>
      <description>My solution function Lazy() { let functions = []; let obj = { add(...args) { functions.push(args); return this; }, invoke(target) { return functions .reduce((acc, cur)=&amp;gt; cur[0].apply(null, [...cur.slice(1), ...acc]),target) } } return obj; }  Finally! This is what expected when people say &amp;ldquo;functional programming&amp;rdquo;. Very-very cool kata, not as complicted algorytm, but about managing functions. Was very interesting. Found half of solution by request &amp;ldquo;how to chain functions&amp;rdquo;, but i had problems with understanding how to pass function with arguments to the list.</description>
    </item>
    
    <item>
      <title>Kata 28: How Much</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/28-how-much/</link>
      <pubDate>Mon, 26 Apr 2021 10:48:20 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/28-how-much/</guid>
      <description>https://www.codewars.com/kata/55b4d87a3766d9873a0000d4
My solution Ok so 6th level for me now is usually not more than 20 mins. I should use it only if know that i will not have a chance to work on bigger kata today.
This was simple.. Just needed some math googling
function howmuch(m, n) { if (m&amp;gt;n) [m,n] = [n,m]; let arr = []; for (let x = m; x&amp;lt;=n; x++) if ((x-1)%9==0 &amp;amp;&amp;amp; (x-2)%7==0) arr = [.</description>
    </item>
    
    <item>
      <title>Kata 27 Backspaces Processing</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/27-backspaces-processing/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/27-backspaces-processing/</guid>
      <description>https://www.codewars.com/kata/5727bb0fe81185ae62000ae3/
My solution function cleanString(s) { return s.split(&amp;#34;&amp;#34;) .reduce((acc,curr)=&amp;gt;curr == &amp;#34;#&amp;#34; ? acc.slice(0,-1) : `${acc}${curr}`,&amp;#34;&amp;#34;) };  This was cool and simple. Clear example of reduce usage. Can&amp;rsquo;t come up with something simpler.
Best another solution Strange, but crowd thinks that push/pop solution is better. Its a mistake. Mine or their&amp;hellip;</description>
    </item>
    
    <item>
      <title>Kata 26: Dont Eat Last Cake</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/26-dont-eat-last-cake/</link>
      <pubDate>Sat, 24 Apr 2021 13:46:33 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/26-dont-eat-last-cake/</guid>
      <description>My solution // Constructor (your Captain Obivious) function Player(){} // Decide who move first - player or opponent (true if player)  const winning = (i) =&amp;gt; { let left = (i - 2) % 4; return (left == 0) ? 0 : left; } Player.prototype.firstmove = function(cakes){ if (cakes==1) return false; if (cakes==2) return false; return (winning(cakes) == 0) ? false : true; } // Decide your next move Player.</description>
    </item>
    
    <item>
      <title>Kata 25 Matching and Substituting</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/25-matching-and-substituting/</link>
      <pubDate>Fri, 23 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/25-matching-and-substituting/</guid>
      <description>https://www.codewars.com/kata/59de1e2fe50813a046000124/
My solution function change(s, prog, version) { let prog_regex = /(?&amp;lt;=Program).*\n/gm; let author_regex = /(?&amp;lt;=Author: ).*\n/gm; let phone_regex = /(?&amp;lt;=Phone: ).*\n/gm let valid_phone_regex = /\+1-\d{3}-\d{3}-\d{4}\n/gm let corp_regex = /Corporation: .*\n/gm; let date_regex = /(?&amp;lt;=Date: )(.*)\n/gm; let vers_regex = /(?&amp;lt;=Version: ).*\n/gm; let valid_vers_regex = /(?&amp;lt;=Version: )\d+\.\d+\n/gm let level_regex = /Level: .*/gm; return !(valid_phone_regex.test(s) &amp;amp;&amp;amp; valid_vers_regex.test(s)) ? &amp;#34;ERROR: VERSION or PHONE&amp;#34; : s.replace(prog_regex, `: ${prog}`) .replace(author_regex, `g964 `) .replace(corp_regex, ``) .replace(phone_regex, `+1-503-555-0090 `) .</description>
    </item>
    
    <item>
      <title>Kata 4: Trailing Zeros</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/4-trailing-zeros/</link>
      <pubDate>Fri, 23 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/4-trailing-zeros/</guid>
      <description>https://www.codewars.com/kata/52f787eb172a8b4ae1000a34/train/javascript
My solution function zeros (n) { let factors5 = [] let num = 1; do factors5 = [...factors5, num *=5]; while (num&amp;lt;n); return factors5.reduce((counter, item)=&amp;gt; counter += Math.floor(n / item), 0) }  Very cool cata, but its pure math, its not that much dev here. I tried 3 approaches - first generate array of digits and then delete all except 2,5 and 0. Too big array. 12s timeout/ 2nd approach was - find how many terms i have - of 2 and 5 and 0.</description>
    </item>
    
    <item>
      <title>Kata 24: Stonks</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/24-stonks/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/24-stonks/</guid>
      <description>https://www.codewars.com/kata/597ef546ee48603f7a000057
My solution const count_sum = (arr)=&amp;gt;arr.reduce((a,b)=&amp;gt;a+b,0) function getMostProfitFromStockQuotes(quotes) { let max = Math.max(...quotes); let income_arr = quotes.slice(0, quotes.indexOf(max)); let income = max * income_arr.length - count_sum(income_arr); if (income &amp;lt; 0) income = 0; let left = quotes.slice(quotes.indexOf(max)+1); return (left.length == 0) ? income : income + getMostProfitFromStockQuotes(left); }  Main problem here was to understand the logic behind the task. At first i didn&amp;rsquo;t get how results in tests are evaluated.</description>
    </item>
    
    <item>
      <title>Kata 23: Meeting</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/23-meeting/</link>
      <pubDate>Tue, 20 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/23-meeting/</guid>
      <description>https://www.codewars.com/kata/59df2f8f08c6cec835000012
My solution const srt = (a,b) =&amp;gt;{ [anew,bnew] = [a.split(&amp;#34;:&amp;#34;), b.split(&amp;#34;:&amp;#34;)]; return (anew[1] == bnew[1]) ? anew[0].localeCompare(bnew[0]) : anew[1].localeCompare(bnew[1]) } const meeting = (s) =&amp;gt; { let res = s.toUpperCase().split(&amp;#34;;&amp;#34;).sort(srt) .reduce((acc,cur)=&amp;gt;{ let names=cur.split(&amp;#34;:&amp;#34;); return `${acc}(${names[1]}, ${names[0]})` },&amp;#34;&amp;#34;) return res; }  It was very interesting to solve this problem, as path is very straightforward, but im not that good in splitting main task into simple ones; in this case i managed to do this without any issues.</description>
    </item>
    
    <item>
      <title>Kata 22: Sorting liquids</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/22-sorting-liquids/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/22-sorting-liquids/</guid>
      <description>https://www.codewars.com/kata/562e6df5cf2d3908ad00019e/solutions/javascript
My solution function separateLiquids(glass) { /// glass[V][H]  const density = { H : 1.36, W : 1.00, A : 0.87, O : 0.80 } const chunkArray = (arr, size) =&amp;gt; arr.length &amp;gt; size ? [arr.slice(0, size), ...chunkArray(arr.slice(size), size)] : [arr]; const srt = (a,b) =&amp;gt; density[a] == density[b] ? 0 : (density[a] &amp;gt; density[b] ? 1 : -1) if (!glass.length) return []; return chunkArray(glass.reduce((a,b)=&amp;gt;[...a, ...b]).sort(srt), glass[0].length) }  This is really cool kata.</description>
    </item>
    
    <item>
      <title>Kata 21: Reverse or rotate?</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/21-reverse-rotate/</link>
      <pubDate>Fri, 16 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/21-reverse-rotate/</guid>
      <description>https://www.codewars.com/kata/56b5afb4ed1f6d5fb0000991/
My solution function revrot(str, sz) { const isSumCubesDivsBy2 = (i) =&amp;gt; i.reduce((acc,curr)=&amp;gt;acc+(+curr)**3, 0) % 2 == 0; let res=[]; if (sz==0) return &amp;#34;&amp;#34;; for (let i=0; i&amp;lt;=str.length; i+=sz) res.push(str.slice(i,i+sz).split(&amp;#34;&amp;#34;)); if (res[res.length-1].length&amp;lt;sz) res=res.slice(0,res.length-1); return res.map(i=&amp;gt;{ return isSumCubesDivsBy2(i) ? i.reverse().join(&amp;#34;&amp;#34;) : [...i.slice(1), i[0]].join(&amp;#34;&amp;#34;) }).join(&amp;#34;&amp;#34;) }  I solved the problem, but in comparison to best answer i see that i don&amp;rsquo;t have enough experience (yet) about organizing code. This thing with 3 const functions looks and reads wonderful.</description>
    </item>
    
    <item>
      <title>Kata 19 Number to Word</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/19-number-to-word/</link>
      <pubDate>Wed, 14 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/19-number-to-word/</guid>
      <description>My solution function number2words(n, result = &amp;#34;&amp;#34;){ const d = { 0:&amp;#34;zero&amp;#34;, 1:&amp;#34;one&amp;#34;, 2:&amp;#34;two&amp;#34;, 3:&amp;#34;three&amp;#34;, 4: &amp;#34;four&amp;#34;, 5:&amp;#34;five&amp;#34;, 6:&amp;#34;six&amp;#34;, 7:&amp;#34;seven&amp;#34;, 8:&amp;#34;eight&amp;#34;, 9:&amp;#34;nine&amp;#34;, 10:&amp;#34;ten&amp;#34;, 11:&amp;#34;eleven&amp;#34;, 12:&amp;#34;twelve&amp;#34;, 13:&amp;#34;thirteen&amp;#34;, 14:&amp;#34;fourteen&amp;#34;, 15:&amp;#34;fifteen&amp;#34;, 16:&amp;#34;sixteen&amp;#34;, 17:&amp;#34;seventeen&amp;#34;, 18:&amp;#34;eighteen&amp;#34;, 19:&amp;#34;nineteen&amp;#34;, 20:&amp;#34;twenty&amp;#34;,30:&amp;#34;thirty&amp;#34;,40:&amp;#34;forty&amp;#34;,50:&amp;#34;fifty&amp;#34;,60:&amp;#34;sixty&amp;#34;,70:&amp;#34;seventy&amp;#34;,80:&amp;#34;eighty&amp;#34;,90:&amp;#34;ninety&amp;#34;, } switch (true) { case (n&amp;lt;=20 || n==30 || n==40 || n==50 || n==60 || n==70 || n==80 || n==90) : result = `${result}${d[n]}`; break; case (n&amp;gt;20 &amp;amp;&amp;amp; n&amp;lt;100): result = `${d[n-n%10]}-${d[n%10]}`; break; case (n%100 == 0 &amp;amp;&amp;amp; n&amp;lt;1000): result = `${d[Math.</description>
    </item>
    
    <item>
      <title>Kata 18: Statistics</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/18-statistics/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/18-statistics/</guid>
      <description>My solution const convToMS = (i) =&amp;gt; { let t = i.split(&amp;#34;|&amp;#34;); return new Date(1970,1,1,t[0],t[1],t[2]).getTime() } const convToDate = (i) =&amp;gt; { let t = new Date(i) return `${zero(t.getHours())}|${zero(t.getMinutes())}|${zero(t.getSeconds())}` } const zero = (i) =&amp;gt; i &amp;lt; 10 ? `0${i}` : i; const stat = (strg) =&amp;gt; { if (!strg) return &amp;#34;&amp;#34;; let tMS = strg.split(&amp;#34;, &amp;#34;).map(convToMS).sort((a,b)=&amp;gt;a-b); let len = tMS.length; let range = tMS[len-1] - tMS[0]; let average = tMS.</description>
    </item>
    
    <item>
      <title>Kata 17: Longest Palindrome</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/17-longest-palindrome/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/17-longest-palindrome/</guid>
      <description>My solution longestPalindrome=function(s){ const checkIfPalindrome = (arr) =&amp;gt; arr.join(&amp;#34;&amp;#34;) == arr.reverse().join(&amp;#34;&amp;#34;) const findMaxPalindrome = (acc,c,ind,arr)=&amp;gt; { let maxP = &amp;#34;&amp;#34;; //check case of odd length palindrome  let j=1; let tryP = c; while((ind-j)&amp;gt;=0 &amp;amp;&amp;amp; (ind+j)&amp;lt;=arr.length) { tryP = [arr[ind-j], ...tryP, arr[ind+j]]; if (checkIfPalindrome(tryP) &amp;amp;&amp;amp; tryP.length &amp;gt; maxP.length) { maxP = tryP.join(&amp;#34;&amp;#34;); } else break; j++; } j=1; tryP = [c, arr[ind+1]]; while((ind-j)&amp;gt;=0 &amp;amp;&amp;amp; (ind+j+1) &amp;lt;= arr.length) { tryP = [arr[ind-j], .</description>
    </item>
    
    <item>
      <title>Kata 16: Count Presses</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/16-count-presses/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/16-count-presses/</guid>
      <description>https://www.codewars.com/kata/54a2e93b22d236498400134b
My solution function presses(phrase) { let combi = [&amp;#39;1&amp;#39;, &amp;#39;ABC2&amp;#39;, &amp;#39;DEF3&amp;#39;, &amp;#39;GHI4&amp;#39;, &amp;#39;JKL5&amp;#39;, &amp;#39;MNO6&amp;#39;, &amp;#39;PQRS7&amp;#39;, &amp;#39;TUV8&amp;#39;, &amp;#39;WXYZ9&amp;#39;, &amp;#39;*&amp;#39;, &amp;#39; 0&amp;#39;, &amp;#39;#&amp;#39; ]; return phrase.toUpperCase().split(&amp;#34;&amp;#34;).reduce((acc, curr)=&amp;gt;{ let word = combi.filter(i=&amp;gt;i.includes(curr))[0]; return acc+word.indexOf(curr)+1; },0); }  Very iportant in this kata for my POV - how to make it simple and effective, so that in real life you can give it diffreent keyboard layouts
But now i think that simples solution might be better - just additional helper to transform layouts to number of presses and store object with &amp;ldquo;symbol&amp;rdquo;:&amp;ldquo;number of presses&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Kata 15: Word of A10n</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/15-word-of-a10n/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/15-word-of-a10n/</guid>
      <description>https://www.codewars.com/kata/5375f921003bf62192000746
My solution const abbreviate = (string) =&amp;gt; string.replace(/\w+/gim, (s)=&amp;gt;s.length&amp;lt;4 ? s : `${s.slice(0,1)}${s.length-2}${s.slice(s.length-1)}`);  Best another solution Oneliner - which i do like. Cool that my solution is actually almost exactly &amp;ldquo;best practices&amp;rdquo; + &amp;ldquo;clever&amp;rdquo; solution.</description>
    </item>
    
    <item>
      <title>Kata 14: Difference Between Arrays</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/14-difference-between-arrays/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/14-difference-between-arrays/</guid>
      <description>https://www.codewars.com/kata/523f5d21c841566fde000009
My solution function arrayDiff(a, b) { return a.reduce((acc, curr) =&amp;gt; b.indexOf(curr) == -1 ? [...acc, curr] : acc, []); }  thought it is very clever until i saw this one:
Best another solution function array_diff(a, b) { return a.filter(e =&amp;gt; !b.includes(e)); }  i forgot about filter&amp;hellip;</description>
    </item>
    
    <item>
      <title>Kata 13: Decomposing Factorial</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/13-decomposing-factorial/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/13-decomposing-factorial/</guid>
      <description>My solution function decomp(n) { const subDecomp = (num,dividers) =&amp;gt; { let rem = num; for (let i=2; i&amp;lt;=Math.sqrt(num); i++) { if (rem % i === 0){ if (!dividers[i]) dividers[i] = 0; while (rem % i === 0){ dividers[i]++; rem /= i; } } } if (rem &amp;gt; 1) dividers[rem] = !dividers[rem] ? 1 :dividers[rem]+1; return dividers; } divs = {}; for (let i=2; i&amp;lt;=n; i++){ divs=subDecomp(i,divs); } return Object.keys(divs).map(x=&amp;gt;divs[x] == 1 ?</description>
    </item>
    
    <item>
      <title>Kata 12: Multiply N Primes</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/12-multiply-n-primes/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/12-multiply-n-primes/</guid>
      <description>My solution function numPrimorial(n){ const findPrimes = (lim) =&amp;gt; { let arr = Array(lim).fill(true); arr[0]=arr[1]=false; for (let i=2; i&amp;lt;=Math.sqrt(lim); i++) if (arr[i] == true) for (j=i*i; j&amp;lt;lim; j+=i) arr[j] = false; return arr.reduce((out, bool, i) =&amp;gt; bool ? out.concat(i) : out, [] ); } primes=[]; for (i=n; primes.length &amp;lt; n; i*=2) primes = findPrimes(i); return primes.slice(0,n).reduce((acc,curr) =&amp;gt; acc *= curr, 1) }  I hope i will finally remember Sieve of Eratosthenes algorytm.</description>
    </item>
    
    <item>
      <title>Kata 10 Sum Maximum Subarray</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/10-sum-maximum-subarray/</link>
      <pubDate>Sun, 04 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/10-sum-maximum-subarray/</guid>
      <description>https://www.codewars.com/kata/54521e9ec8e60bc4de000d6c
My solution var maxSequence = function(arr){ let bestSum = 0; return arr.reduce((acc, curr)=&amp;gt;{ bestSum = (bestSum + curr &amp;gt; curr) ? bestSum + curr : curr; return (acc &amp;gt; bestSum) ? acc : bestSum },0) }  This is another algorytm - Kadane Algorytm, which i have no chance to come up with)) So i just read about it it in wiki and created my understood version of it</description>
    </item>
    
    <item>
      <title>Kata 9 Common Denominator</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/9-common-denominator/</link>
      <pubDate>Sun, 04 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/9-common-denominator/</guid>
      <description>https://www.codewars.com/kata/54d7660d2daf68c619000d95
My solution function convertFrac(lst){ const lcm = (a,b) =&amp;gt; a/gcd(a,b)*b; const gcd = (a,b) =&amp;gt; b==0 ? a : gcd (b, a % b); let commonDenom = lst.map(x=&amp;gt;x[1]).reduce((acc,curr)=&amp;gt;lcm(acc,curr), 1); return lst.reduce((acc,curr)=&amp;gt; `${acc}(${curr[0]*commonDenom / curr[1]},${commonDenom})`,&amp;#34;&amp;#34;) }  I&amp;rsquo;m very proud of my reduce usage, its very cool in this case. Also it was interesting to try again gcd recursion. I hope i will remember algorythm once. At least i remember gcd/lcm terms.</description>
    </item>
    
    <item>
      <title>Kata 8 Rule of divisibility by 13</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/8-divisibility-13/</link>
      <pubDate>Sat, 03 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/8-divisibility-13/</guid>
      <description>https://www.codewars.com/kata/564057bc348c7200bd0000ff
My solution let seq=[1,10,9,12,3,4]; function thirt(n) { let nNew = n.toString().split(&amp;#34;&amp;#34;).reverse().reduce((acc,curr,index)=&amp;gt;{ return acc += +curr*seq[index % 6]; }, 0); if (n == nNew) return n; else { return thirt(nNew); } }  Here i really liked my idea about seq[index % 6]. Task is to apply some fixed sequence to long list of didgits (i don&amp;rsquo;t know what is length of this list). I just take all seprate digits and apply element of sequence with index % 6.</description>
    </item>
    
    <item>
      <title>Kata 7: Break Camelcase</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/7-break-camelcase/</link>
      <pubDate>Thu, 01 Apr 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/7-break-camelcase/</guid>
      <description>https://www.codewars.com/kata/5208f99aee097e6552000148
My solution function solution(string) { return string.split(&amp;#34;&amp;#34;) .reduce((acc,c)=&amp;gt; c.toLowerCase()!=c ? acc+&amp;#34; &amp;#34;+c : acc+c, &amp;#34;&amp;#34;) }  Best another solution I know i know its regexp. Capturing groups, lookahead probably and $1 $2. But i wanted to train reduce, its the only higher order function, which i don&amp;rsquo;t &amp;ldquo;feel&amp;rdquo; yet. But i definitely feel its very powerful.
Solution came suprisingly fast, i just had to remember how to return acc.</description>
    </item>
    
    <item>
      <title>Kata 6 Grandmother Walk</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/6-grandmother-walk/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/6-grandmother-walk/</guid>
      <description>My solution function isValidWalk(walk) { return walk.length == 10 &amp;amp;&amp;amp; walk.filter(x=&amp;gt;x==&amp;#39;n&amp;#39;).length-walk.filter(x=&amp;gt;x==&amp;#39;s&amp;#39;).length == 0 &amp;amp;&amp;amp; walk.filter(x=&amp;gt;x==&amp;#39;e&amp;#39;).length-walk.filter(x=&amp;gt;x==&amp;#39;w&amp;#39;).length == 0 ? true : false; }  // First tried to solve it via reducing array - using its items as commands // then went for some coffee and understand that there is no sense in it, //i can isolate each separate dimension and just count its ++ and &amp;ndash;. // So task is 3 conditions now and became very simple.</description>
    </item>
    
    <item>
      <title>Kata 5 Decode Morse</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/5-decode-morse/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0300</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/5-decode-morse/</guid>
      <description>https://www.codewars.com/kata/54b724efac3d5402db00065e
My solution decodeMorse = function(morseCode){ return morseCode.split(&amp;#34; &amp;#34;).map(word=&amp;gt;word.split(&amp;#34; &amp;#34;).map(ch=&amp;gt;MORSE_CODE[ch]).join(&amp;#34;&amp;#34;)).join(&amp;#34; &amp;#34;).trim(); }  Problem is internal map. I guess for best practices, it would be much better if i had an internal function for decoding separate letters - much readable, and i found such solution at 1st place among best practices
Best another solution decodeMorse = function(morseCode){ return morseCode .trim() .split(/ | /) .map( (code) =&amp;gt; MORSE_CODE[code] || &amp;#39; &amp;#39;) .</description>
    </item>
    
    <item>
      <title>Kata 3: Camel Case</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/3-camel-case/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/3-camel-case/</guid>
      <description>https://www.codewars.com/kata/517abf86da9663f1d2000003
My solution function toCamelCase(str){ return str.split(/[-_]/).map((x,i) =&amp;gt; i==0 ? x : x.charAt(0).toUpperCase() + x.slice(1)).join(&amp;#34;&amp;#34;) }  Main problem here for me was:
 several separators for split (now it know i can use regexp in split(re)) to exclude first character. Solved with checking index, but i think better way may be is to use reduce. But i didn&amp;rsquo;t find how to do it&amp;hellip; Example of something similar is here:  var products = [{ Name: &amp;#39;milk&amp;#39;, price: 2.</description>
    </item>
    
    <item>
      <title>Kata 2: Next Perfect Square</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/2-next-perfect-square/</link>
      <pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/2-next-perfect-square/</guid>
      <description>https://www.codewars.com/kata/56269eb78ad2e4ced1000013
My solution function findNextSquare(sq) { let base = Math.sqrt(sq); return base % 1 != 0 ? -1 : (base+1)*(base+1); }  </description>
    </item>
    
    <item>
      <title>Kata 1: Vowel Count</title>
      <link>https://mikhailspirin.github.io/codewars-blog/post/1-vowel-count/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://mikhailspirin.github.io/codewars-blog/post/1-vowel-count/</guid>
      <description>https://www.codewars.com/kata/54ff3102c1bad923760001f3/
My solution Return the number (count) of vowels in the given string.
function getCount(str) { let vowelsArr = str.match(/[aeiou]/ig) return vowelsArr != null ? vowelsArr.length : 0; }  Best another solution Cool lesson is working with null - this is clever solution:
const getCount = (str)=&amp;gt;(str.match(/[aeiou]/ig)||[]).length;  </description>
    </item>
    
  </channel>
</rss>
